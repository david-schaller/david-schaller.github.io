<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>asymmetree.treeevolve.RateHeterogeneity API documentation</title>
<meta name="description" content="Evolution rate heterogeneity â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>asymmetree.treeevolve.RateHeterogeneity</code></h1>
</header>
<section id="section-intro">
<p>Evolution rate heterogeneity.</p>
<p>Introduce evolution rate asymmetries and autocorrelation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
Evolution rate heterogeneity.

Introduce evolution rate asymmetries and autocorrelation.
&#34;&#34;&#34;

from warnings import warn

import numpy as np

from asymmetree.treeevolve.GeneTree import GeneTreeSimulator
from asymmetree.tools.Sampling import Sampler
from asymmetree.tools.PhyloTreeTools import sorted_nodes


__author__ = &#39;David Schaller&#39;


# --------------------------------------------------------------------------
#                         USER INTERFACE FUNCTION
# --------------------------------------------------------------------------

def gene_trees(S,
               n=1,
               dupl_rate=0.0,
               loss_rate=0.0,
               hgt_rate=0.0,
               base_rate=1.0,
               **kwargs):
    &#34;&#34;&#34;Simulates dated gene trees with non-ultrametric edge lengths along a
    species tree.
    
    Parameters
    ----------
    S : Tree
        The species tree along which the gene trees are simulated.
    n : int, optional
        Number of gene trees to be simulated, default is 1, in which case a
        tree is returned, otherwise a list is returned.
    dupl_rate : float or tuple
        The (distribution for the) duplication rate, see documentation for
        available option. The default is constant 0.0.
    loss_rate : float or tuple
        The (distribution for the) loss rate, see documentation for
        available option. The default is constant 0.0.
    hgt_rate : float or tuple
        The (distribution for the) HGT rate, see documentation for
        available option. The default is constant 0.0.
    base_rate : float or tuple
        The (distribution for the) evolution rate at the roots of the gene
        trees, see documentation for available options. The default is
        constant 1.0.
    kwargs : optional
        See documentation or parameters of GeneTreeSimulator.simulate() and
        rate_heterogeneity() for additional parameters.
    
    Returns
    -------
    list
        A list of simulated gene tree.
    &#34;&#34;&#34;
    
    gene_trees = []
    simulator = GeneTreeSimulator(S)
    
    dupl_rate_sampler = Sampler(dupl_rate)
    loss_rate_sampler = Sampler(loss_rate)
    hgt_rate_sampler = Sampler(hgt_rate)
    base_rate_sampler = Sampler(dupl_rate)
    
    # autocorrelation between genes of the same or related species
    autocorr_variance = kwargs.pop(&#39;autocorr_variance&#39;, 0.0)
    _, autocorr_factors = autocorrelation_factors(S, autocorr_variance)
    
    # main simulation and imbalancing
    for i in range(n):
        TGT = simulator.simulate(dupl_rate=dupl_rate_sampler(),
                                 loss_rate=loss_rate_sampler(),
                                 hgt_rate=hgt_rate_sampler(),
                                 **kwargs)
        rate_heterogeneity(TGT, S,
                           base_rate=base_rate_sampler(),
                           autocorr_factors=autocorr_factors,
                           **kwargs)
        gene_trees.append(TGT)
    
    return gene_trees
    

# --------------------------------------------------------------------------
#                      evolution rate heterogeneity
# --------------------------------------------------------------------------

def rate_heterogeneity(T, S,
                       base_rate=1.0,
                       autocorr_factors=None,
                       autocorr_variance=0.0,
                       rate_increase=(&#39;gamma&#39;, 0.5, 2.2),
                       CSN_weights=(1, 1, 1),
                       inplace=True,
                       **kwargs):
    &#34;&#34;&#34;Introduces evolution rate heterogeneity into a gene tree.
    
    The function applies rate multiplier for three sources of evolution rate
    heterogeneity: (i) gene-family-specific heterogeneity is modeled through
    the &#39;base_rate&#39; parameter; (ii) for species-specific heterogeneity an
    autocorrelated relaxed molecular clock model as in [1] is used; and (iii)
    for paralog-secific heterogeneity it is chosen between the three modes
    conservation, subfunctionalization, and neofunctionalization for the rates
    of the descendant lineages of a duplication event.
    The assigned rates are used to modify the length (&#39;dist&#39;) of the edges of
    the (originally ultrametric) dated gene tree.
    
    Parameters
    ----------
    T : Tree
        The gene tree.
    S : Tree
        The species tree.
    base_rate : float, optional
        Mean of substitution rate for conserved genes.
    autocorr_factors : dict, optional
        A dictonary containing autocorrelation rate factors for the edges of S
        (key = v.label for edge (v.parent, v); value = the rate as a float).
        The default is None, in which case autocorrelation factors are 
        generated if &#39;autocorr_variance&#39; &gt; 0.0, or no such modification is
        applied. See [1] for theoretical background.
    autocorr_variance : float, optional
        Autocorrelation variance factor for a lognormal distribution, only
        considered if &#39;autocorrelation_rates&#39; are not supplied. See [1] for
        theoretical background.
    rate_increase : float or tuple, optional
        Distribution of the (relative) rate increase (w.r.t. the base rate)
        for divergent genes, i.e. to a factor 1 + x. The default is a Gamma
        distribution with shape 0.5 and scale 2.2, which was fitted to the
        data in [2].
    CSN_weights : tuple, optional
        Weights for choice between conservation, subfunctionalization and
        neofunctionalization. The default is (1, 1, ,1), i.e., all three modes
        are equally likely to be chosen at each duplication event.
    inplace : bool, optional
        If False, copy the tree before imbalancing. The deafault is True.
    
    Returns
    -------
    Tree
        The original instance of the gene tree (inplace=True) or a copy of
        the gene tree (inplace=False) with modified &#39;dist&#39; attributes of the
        nodes.
    
    References
    ----------
    .. [1] H. Kishino, J. L. Thorne, and W. J. Bruno.
       Performance of a Divergence Time Estimation Method under a Probabilistic
       Model of Rate Evolution. 
       In: Molecular Biology and Evolution, 18(3):352-361, March 2001.
       doi: 10.1093/oxfordjournals.molbev.a003811.
    .. [2] K. P. Byrne and K. H. Wolfe.
       Consistent Patterns of Rate Asymmetry and Gene Loss Indicate Widespread
       Neofunctionalization of Yeast Genes After Whole-Genome Duplication.
       In: Genetics, 175(3):1341-1350, March 2007.
       doi: 10.1534/genetics.106.066951.
    &#34;&#34;&#34;
    
    if not inplace:
        T = T.copy()
     
    # paralog-specific rate heterogeneity (neo- and subfunctionalization)
    _divergent_rates(T, S, 
                     Sampler(rate_increase, shift=1.0), 
                     np.asarray(CSN_weights) / sum(CSN_weights))
    
    # species-specific rate heterogeneity (autocorrelation)
    if not autocorr_factors and autocorr_variance &gt; 0.0:
        _, autocorr_factors = autocorrelation_factors(S, autocorr_variance)
    if autocorr_factors:
        for v in T.preorder():
            if v.parent:
                edge_ID = v.reconc[1] if isinstance(v.reconc, (tuple, list)) \
                                     else v.reconc
                v.dist *= autocorr_factors[edge_ID]
    
    # gene-family-specific rate heterogeneity (base rate)
    for v in T.preorder():
        v.dist *= base_rate
    
    return T

def assign_rates(T, S, **kwargs):
    
    warn(&#39;This method is deprecated. Use rate_heterogeneity() instead.&#39;,
         DeprecationWarning, stacklevel=2)
    return rate_heterogeneity(T, S, **kwargs)


# --------------------------------------------------------------------------
#     paralog-specific rate heterogeneity (neo- and subfunctionalization)
# --------------------------------------------------------------------------

def _adjust_distances(T, rates):
    
    for edge, rate_list in rates.items():
        time_points = np.asarray([tstamp for tstamp, _ in rate_list] +
                                 [edge[1].tstamp])
        rate_values = np.asarray([rate for _, rate in rate_list])
        edge[1].dist = np.dot(-np.diff(time_points), rate_values)


def _divergent_rates(T, S, sampler, CSN_weights):
    &#34;&#34;&#34;Assign divergent genes and manipulate the distances in the gene tree.
    
    Parameters
    ----------
    T : Tree
        The gene tree.
    S : Tree
        The species tree.
    sampler : asymmetree.tools.Sampling.Sampler
        Sampler for rate increase for divergent genes.
    CSN_weights : tuple
         Weights for choice between conservation, subfunctionalization and
         neofunctionalization.
    
    Returns
    -------
    Tree
        The original gene tree instance with manipulated &#39;dist&#39; attributes of
        its nodes.
    &#34;&#34;&#34;
    
    T_nodes = sorted_nodes(T)
    
    # edge --&gt; list of (tstamp, rate) tuples
    rates = {edge: [] for edge in T.edges()}
    
    S_parents = {v.label: v.parent.label for v in S.preorder() if v.parent}
    gene_counter = {(u.label, v.label): [] for u, v in S.edges()}
    
    # nodes willl be marked as conserved or divergent
    marked = {v: &#39;conserved&#39; for v in T_nodes}
    
    for u in T_nodes:
        
        # ----------------- SPECIATION -----------------
        if u.event in (&#39;S&#39;, &#39;&#39;, None):
            for v in u.children:
                marked[v] = marked[u]
                S_u = u.reconc
                S_v = v.reconc if not isinstance(v.reconc, (tuple, list)) \
                      else v.reconc[1]
                gene_counter[(S_u, S_v)].append(v)
                new_rate = sampler() if marked[v] == &#39;divergent&#39; else 1.0
                rates[(u,v)].append((u.tstamp, new_rate))
            
        # ---------------- DUPLICATION -----------------
        elif u.event == &#39;D&#39; or u.event == &#39;GC&#39;:
            
            gene_counter[u.reconc].remove(u)
            
            # will contain the indices of the conserved descendants
            conserved = set()
            
            if marked[u] != &#39;divergent&#39;:
                # if parental lineage was divergent or subfunctionalization
                # is drawn below, all descendant lineages are divergent
                
                r = np.random.choice(3, p=CSN_weights)
                if r == 0:
                    # conservation: all descendants conserved
                    conserved.update(range(len(u.children)))
                elif r == 2:
                    # neofunctionalization: exactly 1 descendant conserved
                    conserved.add(np.random.randint(len(u.children)))
                    
            for i, v in enumerate(u.children):
                
                if i in conserved:
                    marked[v] = &#39;conserved&#39;
                    new_rate = 1.0
                else:
                    marked[v] = &#39;divergent&#39;
                    new_rate = sampler()
                    
                gene_counter[u.reconc].append(v)
                rates[(u,v)].append((u.tstamp, new_rate))
        
        # ------------------- LOSS ---------------------
        elif u.event == &#39;L&#39;:
            gene_counter[u.reconc].remove(u)
            
            if len(gene_counter[u.reconc]) == 1:
                # if only one lineage remains in the species, set its status
                # to conserved
                v = gene_counter[u.reconc][0]
                if marked[v] == &#39;divergent&#39;:
                    marked[v] = &#39;conserved&#39;
                    rates[(v.parent,v)].append((u.tstamp, 1.0))
        
        # ---------- HORIZONTAL GENE TRANSFER ----------
        elif u.event == &#39;H&#39;:
            v1, v2 = u.children
            if v1.transferred:
                v1, v2 = v2, v1         # now v2 is the transferred copy
                
            # untransferred copy
            marked[v1] = marked[u]
            gene_counter[u.reconc].remove(u)
            gene_counter[u.reconc].append(v1)
            if u.parent:
                rates[(u,v1)].append((u.tstamp, rates[(u.parent,u)][-1][1]))
            else:
                new_rate = sampler() if marked[v1] == &#39;divergent&#39; else 1.0
                rates[(u,v1)].append((u.tstamp, new_rate))
            
            # transferred copy
            S_edge = v2.reconc if isinstance(v2.reconc, (tuple, list)) \
                     else (S_parents[v2.reconc], v2.reconc)
            gene_counter[S_edge].append(v2)
            if len(gene_counter[S_edge]) == 1:
                marked[v2] = &#39;conserved&#39;
                new_rate = 1.0
            else:
                marked[v2] = &#39;divergent&#39;
                new_rate = sampler()
            rates[(u,v2)].append((u.tstamp, new_rate))
            
    _adjust_distances(T, rates)
    
    return T

# --------------------------------------------------------------------------
#           species-specific rate heterogeneity (autocorrelation)
# --------------------------------------------------------------------------
    
def autocorrelation_factors(tree, variance):
    &#34;&#34;&#34;Lognormal model to assign rate factors to a species tree.
    
    The parameter &#39;variance&#39; is a hyperparameter for a log-normal distribution
    from which offspring rates are drawn. The overall variance of this
    distribution is &#39;variance&#39; * divergence time.
    The rates are first computed for the nodes, the rates of the edges are
    assigned afterwards as the arithmetic mean of the rates of the two incident
    nodes.
    
    Parameters
    ----------
    tree : Tree
        The species tree.
    variance : float
        The hyperparameter for a log-normal distribution from which offspring
        rates are drawn at each node.
    
    Returns
    -------
    tuple of two dicts
        A dict mapping the labels of the nodel to their assigned rated, and a
        second dict mapping the labels of v of edges (v.parent, v) to the
        assigned rates of the edges.
    
    References
    ----------
    .. [1] H. Kishino, J. L. Thorne, and W. J. Bruno.
       Performance of a Divergence Time Estimation Method under a Probabilistic
       Model of Rate Evolution. 
       In: Molecular Biology and Evolution, 18(3):352-361, March 2001.
       doi: 10.1093/oxfordjournals.molbev.a003811.
    &#34;&#34;&#34;
    
    node_rates = {}                 # maps node v --&gt; rate of v
    edge_rates = {}                 # maps v of edge (u,v) --&gt; rate of (u,v)
    
    for v in tree.preorder():
        if not v.parent:
            # assign factor 1.0 to root (= expected value for all other nodes
            # and edges)
            node_rates[v.label] = 1.0
            edge_rates[v.label] = 1.0
        else:
            var = variance * v.dist
            # ensure that exp. value is equal to parent&#39;s rate
            mu = np.log(node_rates[v.parent.label]) - var/2
            
            node_rates[v.label] = np.exp(np.random.normal(mu, np.sqrt(var)))
            
            # edge rate as arithmetic mean of u and v
            edge_rates[v.label] = (node_rates[v.parent.label] + 
                                   node_rates[v.label]) / 2
            
    return node_rates, edge_rates</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="asymmetree.treeevolve.RateHeterogeneity.assign_rates"><code class="name flex">
<span>def <span class="ident">assign_rates</span></span>(<span>T, S, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_rates(T, S, **kwargs):
    
    warn(&#39;This method is deprecated. Use rate_heterogeneity() instead.&#39;,
         DeprecationWarning, stacklevel=2)
    return rate_heterogeneity(T, S, **kwargs)</code></pre>
</details>
</dd>
<dt id="asymmetree.treeevolve.RateHeterogeneity.autocorrelation_factors"><code class="name flex">
<span>def <span class="ident">autocorrelation_factors</span></span>(<span>tree, variance)</span>
</code></dt>
<dd>
<div class="desc"><p>Lognormal model to assign rate factors to a species tree.</p>
<p>The parameter 'variance' is a hyperparameter for a log-normal distribution
from which offspring rates are drawn. The overall variance of this
distribution is 'variance' * divergence time.
The rates are first computed for the nodes, the rates of the edges are
assigned afterwards as the arithmetic mean of the rates of the two incident
nodes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tree</code></strong> :&ensp;<code>Tree</code></dt>
<dd>The species tree.</dd>
<dt><strong><code>variance</code></strong> :&ensp;<code>float</code></dt>
<dd>The hyperparameter for a log-normal distribution from which offspring
rates are drawn at each node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>two dicts</code></dt>
<dd>A dict mapping the labels of the nodel to their assigned rated, and a
second dict mapping the labels of v of edges (v.parent, v) to the
assigned rates of the edges.</dd>
</dl>
<h2 id="references">References</h2>
<p>.. [1] H. Kishino, J. L. Thorne, and W. J. Bruno.
Performance of a Divergence Time Estimation Method under a Probabilistic
Model of Rate Evolution.
In: Molecular Biology and Evolution, 18(3):352-361, March 2001.
doi: 10.1093/oxfordjournals.molbev.a003811.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autocorrelation_factors(tree, variance):
    &#34;&#34;&#34;Lognormal model to assign rate factors to a species tree.
    
    The parameter &#39;variance&#39; is a hyperparameter for a log-normal distribution
    from which offspring rates are drawn. The overall variance of this
    distribution is &#39;variance&#39; * divergence time.
    The rates are first computed for the nodes, the rates of the edges are
    assigned afterwards as the arithmetic mean of the rates of the two incident
    nodes.
    
    Parameters
    ----------
    tree : Tree
        The species tree.
    variance : float
        The hyperparameter for a log-normal distribution from which offspring
        rates are drawn at each node.
    
    Returns
    -------
    tuple of two dicts
        A dict mapping the labels of the nodel to their assigned rated, and a
        second dict mapping the labels of v of edges (v.parent, v) to the
        assigned rates of the edges.
    
    References
    ----------
    .. [1] H. Kishino, J. L. Thorne, and W. J. Bruno.
       Performance of a Divergence Time Estimation Method under a Probabilistic
       Model of Rate Evolution. 
       In: Molecular Biology and Evolution, 18(3):352-361, March 2001.
       doi: 10.1093/oxfordjournals.molbev.a003811.
    &#34;&#34;&#34;
    
    node_rates = {}                 # maps node v --&gt; rate of v
    edge_rates = {}                 # maps v of edge (u,v) --&gt; rate of (u,v)
    
    for v in tree.preorder():
        if not v.parent:
            # assign factor 1.0 to root (= expected value for all other nodes
            # and edges)
            node_rates[v.label] = 1.0
            edge_rates[v.label] = 1.0
        else:
            var = variance * v.dist
            # ensure that exp. value is equal to parent&#39;s rate
            mu = np.log(node_rates[v.parent.label]) - var/2
            
            node_rates[v.label] = np.exp(np.random.normal(mu, np.sqrt(var)))
            
            # edge rate as arithmetic mean of u and v
            edge_rates[v.label] = (node_rates[v.parent.label] + 
                                   node_rates[v.label]) / 2
            
    return node_rates, edge_rates</code></pre>
</details>
</dd>
<dt id="asymmetree.treeevolve.RateHeterogeneity.gene_trees"><code class="name flex">
<span>def <span class="ident">gene_trees</span></span>(<span>S, n=1, dupl_rate=0.0, loss_rate=0.0, hgt_rate=0.0, base_rate=1.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulates dated gene trees with non-ultrametric edge lengths along a
species tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>Tree</code></dt>
<dd>The species tree along which the gene trees are simulated.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of gene trees to be simulated, default is 1, in which case a
tree is returned, otherwise a list is returned.</dd>
<dt><strong><code>dupl_rate</code></strong> :&ensp;<code>float</code> or <code>tuple</code></dt>
<dd>The (distribution for the) duplication rate, see documentation for
available option. The default is constant 0.0.</dd>
<dt><strong><code>loss_rate</code></strong> :&ensp;<code>float</code> or <code>tuple</code></dt>
<dd>The (distribution for the) loss rate, see documentation for
available option. The default is constant 0.0.</dd>
<dt><strong><code>hgt_rate</code></strong> :&ensp;<code>float</code> or <code>tuple</code></dt>
<dd>The (distribution for the) HGT rate, see documentation for
available option. The default is constant 0.0.</dd>
<dt><strong><code>base_rate</code></strong> :&ensp;<code>float</code> or <code>tuple</code></dt>
<dd>The (distribution for the) evolution rate at the roots of the gene
trees, see documentation for available options. The default is
constant 1.0.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>optional</code></dt>
<dd>See documentation or parameters of GeneTreeSimulator.simulate() and
rate_heterogeneity() for additional parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of simulated gene tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gene_trees(S,
               n=1,
               dupl_rate=0.0,
               loss_rate=0.0,
               hgt_rate=0.0,
               base_rate=1.0,
               **kwargs):
    &#34;&#34;&#34;Simulates dated gene trees with non-ultrametric edge lengths along a
    species tree.
    
    Parameters
    ----------
    S : Tree
        The species tree along which the gene trees are simulated.
    n : int, optional
        Number of gene trees to be simulated, default is 1, in which case a
        tree is returned, otherwise a list is returned.
    dupl_rate : float or tuple
        The (distribution for the) duplication rate, see documentation for
        available option. The default is constant 0.0.
    loss_rate : float or tuple
        The (distribution for the) loss rate, see documentation for
        available option. The default is constant 0.0.
    hgt_rate : float or tuple
        The (distribution for the) HGT rate, see documentation for
        available option. The default is constant 0.0.
    base_rate : float or tuple
        The (distribution for the) evolution rate at the roots of the gene
        trees, see documentation for available options. The default is
        constant 1.0.
    kwargs : optional
        See documentation or parameters of GeneTreeSimulator.simulate() and
        rate_heterogeneity() for additional parameters.
    
    Returns
    -------
    list
        A list of simulated gene tree.
    &#34;&#34;&#34;
    
    gene_trees = []
    simulator = GeneTreeSimulator(S)
    
    dupl_rate_sampler = Sampler(dupl_rate)
    loss_rate_sampler = Sampler(loss_rate)
    hgt_rate_sampler = Sampler(hgt_rate)
    base_rate_sampler = Sampler(dupl_rate)
    
    # autocorrelation between genes of the same or related species
    autocorr_variance = kwargs.pop(&#39;autocorr_variance&#39;, 0.0)
    _, autocorr_factors = autocorrelation_factors(S, autocorr_variance)
    
    # main simulation and imbalancing
    for i in range(n):
        TGT = simulator.simulate(dupl_rate=dupl_rate_sampler(),
                                 loss_rate=loss_rate_sampler(),
                                 hgt_rate=hgt_rate_sampler(),
                                 **kwargs)
        rate_heterogeneity(TGT, S,
                           base_rate=base_rate_sampler(),
                           autocorr_factors=autocorr_factors,
                           **kwargs)
        gene_trees.append(TGT)
    
    return gene_trees</code></pre>
</details>
</dd>
<dt id="asymmetree.treeevolve.RateHeterogeneity.rate_heterogeneity"><code class="name flex">
<span>def <span class="ident">rate_heterogeneity</span></span>(<span>T, S, base_rate=1.0, autocorr_factors=None, autocorr_variance=0.0, rate_increase=('gamma', 0.5, 2.2), CSN_weights=(1, 1, 1), inplace=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Introduces evolution rate heterogeneity into a gene tree.</p>
<p>The function applies rate multiplier for three sources of evolution rate
heterogeneity: (i) gene-family-specific heterogeneity is modeled through
the 'base_rate' parameter; (ii) for species-specific heterogeneity an
autocorrelated relaxed molecular clock model as in [1] is used; and (iii)
for paralog-secific heterogeneity it is chosen between the three modes
conservation, subfunctionalization, and neofunctionalization for the rates
of the descendant lineages of a duplication event.
The assigned rates are used to modify the length ('dist') of the edges of
the (originally ultrametric) dated gene tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>Tree</code></dt>
<dd>The gene tree.</dd>
<dt><strong><code>S</code></strong> :&ensp;<code>Tree</code></dt>
<dd>The species tree.</dd>
<dt><strong><code>base_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Mean of substitution rate for conserved genes.</dd>
<dt><strong><code>autocorr_factors</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>A dictonary containing autocorrelation rate factors for the edges of S
(key = v.label for edge (v.parent, v); value = the rate as a float).
The default is None, in which case autocorrelation factors are
generated if 'autocorr_variance' &gt; 0.0, or no such modification is
applied. See [1] for theoretical background.</dd>
<dt><strong><code>autocorr_variance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Autocorrelation variance factor for a lognormal distribution, only
considered if 'autocorrelation_rates' are not supplied. See [1] for
theoretical background.</dd>
<dt><strong><code>rate_increase</code></strong> :&ensp;<code>float</code> or <code>tuple</code>, optional</dt>
<dd>Distribution of the (relative) rate increase (w.r.t. the base rate)
for divergent genes, i.e. to a factor 1 + x. The default is a Gamma
distribution with shape 0.5 and scale 2.2, which was fitted to the
data in [2].</dd>
<dt><strong><code>CSN_weights</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Weights for choice between conservation, subfunctionalization and
neofunctionalization. The default is (1, 1, ,1), i.e., all three modes
are equally likely to be chosen at each duplication event.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If False, copy the tree before imbalancing. The deafault is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tree</code></dt>
<dd>The original instance of the gene tree (inplace=True) or a copy of
the gene tree (inplace=False) with modified 'dist' attributes of the
nodes.</dd>
</dl>
<h2 id="references">References</h2>
<p>.. [1] H. Kishino, J. L. Thorne, and W. J. Bruno.
Performance of a Divergence Time Estimation Method under a Probabilistic
Model of Rate Evolution.
In: Molecular Biology and Evolution, 18(3):352-361, March 2001.
doi: 10.1093/oxfordjournals.molbev.a003811.
.. [2] K. P. Byrne and K. H. Wolfe.
Consistent Patterns of Rate Asymmetry and Gene Loss Indicate Widespread
Neofunctionalization of Yeast Genes After Whole-Genome Duplication.
In: Genetics, 175(3):1341-1350, March 2007.
doi: 10.1534/genetics.106.066951.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rate_heterogeneity(T, S,
                       base_rate=1.0,
                       autocorr_factors=None,
                       autocorr_variance=0.0,
                       rate_increase=(&#39;gamma&#39;, 0.5, 2.2),
                       CSN_weights=(1, 1, 1),
                       inplace=True,
                       **kwargs):
    &#34;&#34;&#34;Introduces evolution rate heterogeneity into a gene tree.
    
    The function applies rate multiplier for three sources of evolution rate
    heterogeneity: (i) gene-family-specific heterogeneity is modeled through
    the &#39;base_rate&#39; parameter; (ii) for species-specific heterogeneity an
    autocorrelated relaxed molecular clock model as in [1] is used; and (iii)
    for paralog-secific heterogeneity it is chosen between the three modes
    conservation, subfunctionalization, and neofunctionalization for the rates
    of the descendant lineages of a duplication event.
    The assigned rates are used to modify the length (&#39;dist&#39;) of the edges of
    the (originally ultrametric) dated gene tree.
    
    Parameters
    ----------
    T : Tree
        The gene tree.
    S : Tree
        The species tree.
    base_rate : float, optional
        Mean of substitution rate for conserved genes.
    autocorr_factors : dict, optional
        A dictonary containing autocorrelation rate factors for the edges of S
        (key = v.label for edge (v.parent, v); value = the rate as a float).
        The default is None, in which case autocorrelation factors are 
        generated if &#39;autocorr_variance&#39; &gt; 0.0, or no such modification is
        applied. See [1] for theoretical background.
    autocorr_variance : float, optional
        Autocorrelation variance factor for a lognormal distribution, only
        considered if &#39;autocorrelation_rates&#39; are not supplied. See [1] for
        theoretical background.
    rate_increase : float or tuple, optional
        Distribution of the (relative) rate increase (w.r.t. the base rate)
        for divergent genes, i.e. to a factor 1 + x. The default is a Gamma
        distribution with shape 0.5 and scale 2.2, which was fitted to the
        data in [2].
    CSN_weights : tuple, optional
        Weights for choice between conservation, subfunctionalization and
        neofunctionalization. The default is (1, 1, ,1), i.e., all three modes
        are equally likely to be chosen at each duplication event.
    inplace : bool, optional
        If False, copy the tree before imbalancing. The deafault is True.
    
    Returns
    -------
    Tree
        The original instance of the gene tree (inplace=True) or a copy of
        the gene tree (inplace=False) with modified &#39;dist&#39; attributes of the
        nodes.
    
    References
    ----------
    .. [1] H. Kishino, J. L. Thorne, and W. J. Bruno.
       Performance of a Divergence Time Estimation Method under a Probabilistic
       Model of Rate Evolution. 
       In: Molecular Biology and Evolution, 18(3):352-361, March 2001.
       doi: 10.1093/oxfordjournals.molbev.a003811.
    .. [2] K. P. Byrne and K. H. Wolfe.
       Consistent Patterns of Rate Asymmetry and Gene Loss Indicate Widespread
       Neofunctionalization of Yeast Genes After Whole-Genome Duplication.
       In: Genetics, 175(3):1341-1350, March 2007.
       doi: 10.1534/genetics.106.066951.
    &#34;&#34;&#34;
    
    if not inplace:
        T = T.copy()
     
    # paralog-specific rate heterogeneity (neo- and subfunctionalization)
    _divergent_rates(T, S, 
                     Sampler(rate_increase, shift=1.0), 
                     np.asarray(CSN_weights) / sum(CSN_weights))
    
    # species-specific rate heterogeneity (autocorrelation)
    if not autocorr_factors and autocorr_variance &gt; 0.0:
        _, autocorr_factors = autocorrelation_factors(S, autocorr_variance)
    if autocorr_factors:
        for v in T.preorder():
            if v.parent:
                edge_ID = v.reconc[1] if isinstance(v.reconc, (tuple, list)) \
                                     else v.reconc
                v.dist *= autocorr_factors[edge_ID]
    
    # gene-family-specific rate heterogeneity (base rate)
    for v in T.preorder():
        v.dist *= base_rate
    
    return T</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="asymmetree.treeevolve" href="index.html">asymmetree.treeevolve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="asymmetree.treeevolve.RateHeterogeneity.assign_rates" href="#asymmetree.treeevolve.RateHeterogeneity.assign_rates">assign_rates</a></code></li>
<li><code><a title="asymmetree.treeevolve.RateHeterogeneity.autocorrelation_factors" href="#asymmetree.treeevolve.RateHeterogeneity.autocorrelation_factors">autocorrelation_factors</a></code></li>
<li><code><a title="asymmetree.treeevolve.RateHeterogeneity.gene_trees" href="#asymmetree.treeevolve.RateHeterogeneity.gene_trees">gene_trees</a></code></li>
<li><code><a title="asymmetree.treeevolve.RateHeterogeneity.rate_heterogeneity" href="#asymmetree.treeevolve.RateHeterogeneity.rate_heterogeneity">rate_heterogeneity</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>