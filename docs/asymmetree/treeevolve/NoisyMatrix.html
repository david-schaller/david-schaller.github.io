<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>asymmetree.treeevolve.NoisyMatrix API documentation</title>
<meta name="description" content="Noisy Matrix …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>asymmetree.treeevolve.NoisyMatrix</code></h1>
</header>
<section id="section-intro">
<p>Noisy Matrix.</p>
<p>Introduce noise into a distance matrix.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
Noisy Matrix.

Introduce noise into a distance matrix.
&#34;&#34;&#34;

import random
import numpy as np

from tralda.datastructures.Tree import Tree, TreeNode
from asymmetree.tools.PhyloTreeTools import distance_matrix


__author__ = &#34;David Schaller&#34;


# --------------------------------------------------------------------------
#                      RANDOM PERTURBATION NOISE
#   
# --------------------------------------------------------------------------

def noisy_matrix(orig_matrix, sd, metric_repair=&#39;reject&#39;):
    &#34;&#34;&#34;Disturb a distance matrix (which must be a metric) with random noise.
    
    Parameters
    ----------
    orig_matrix : 2-dimensional numpy array
        The distance matrix.
    sd : float
        Disturbance parameter. Serves as standard deviation of a normal
        distrubition with mean 1.0.
    metric_repair : str, optional
        Strategy to ensure that the resulting matrix is still a metric and,
        in particular, satisfies the triangle inequality.
        The default is &#39;reject&#39;, see [1]. Other avaible options are &#39;general&#39;
        and &#39;DOMR&#39;, see [2].
    
    Returns
    -------
    2-dim. numpy array
        The disturbed distance matrix.
        
    References
    ----------
    .. [1] P. F. Stadler, M. Geiß, D. Schaller, A. López Sánchez, M. González 
       Laffitte, D. Valdivia, M. Hellmuth, M. Hernández Rosales.
       From pairs of most similar sequences to phylogenetic best matches.
       In: Alg. Mol. Biol., 2020, 15, 5.
       doi: 10.1186/s13015-020-00165-2.
    .. [2] A. C. Gilbert, L. Jain.
       If it ain&#39;t broke, don&#39;t  x it: Sparse metric repair. 
       In: 2017 55th Annual Allerton Conference on Communication, Control, and
       Computing (Allerton), pages 612-619, Monticello, IL, USA, October 2017.
       IEEE. ISBN 978-1-5386-3266-6.
       doi: 10.1109/ALLERTON.2017.8262793.
    &#34;&#34;&#34;
    
    if metric_repair == &#39;general&#39;:
        return _noise_general_metric_repair(orig_matrix, sd)
    elif metric_repair == &#39;DOMR&#39;:
        return _noise_metric_repair_DOMR(orig_matrix, sd)
    elif metric_repair == &#39;reject&#39;:
        return _noise_reject_method(orig_matrix, sd)
    else:
        raise ValueError(&#34;illegal argument &#39;{}&#39;&#34;.format(metric_repair))

    
def _noise_reject_method(orig_matrix, sd):
    &#34;&#34;&#34;Return a matrix D&#39; with noise by accept/reject algorithm.&#34;&#34;&#34;
    
    D = np.array(orig_matrix, copy=True)
    N = D.shape[0]
    
    success_count = 0
    stop_at = N * (N-1) / 2
    
    while success_count &lt; stop_at:
        i, j = np.random.randint(N, size=2)
        while i == j:
            j = np.random.randint(N)
        old_distance = D[i,j].copy()
        new_distance = 0.0
        while new_distance &lt;= 0.0:
            new_distance = D[i,j] * np.random.normal(loc=1.0, scale=sd)
        D[i,j] = new_distance
        D[j,i] = new_distance
        
        
        if (D[i,j] &gt; np.min(D[i,:] + D[:,j]) or
            np.any( D[:,i] &gt; D[:,j] + D[j,i] ) or
            np.any( D[:,j] &gt; D[:,i] + D[i,j] )):
            D[i,j] = old_distance
            D[j,i] = old_distance
        else:
            success_count += 1
    
    return D


def _noise_metric_repair_DOMR(orig_matrix, sd):
    &#34;&#34;&#34;Return a matrix D&#39; with noise by metric repair (DOMR) algorithm.&#34;&#34;&#34;
    
    D = np.array(orig_matrix, copy=True)
    N = D.shape[0]
    
    for i in range(N-1):                        # noise introduction
        for j in range(i+1, N):
            new_distance = 0.0
            while new_distance &lt;= 0.0:
                new_distance = D[i,j] * np.random.normal(loc=1.0, scale=sd)
            D[i,j] = new_distance
            D[j,i] = new_distance
    
    for k in range(N):                          # metric repair: decrease
        for i in range(N):                      # only metric repair (DOMR)
            for j in range(i):                  # with Floyd-Warshall
                if D[i,j] &gt;= D[i,k] + D[k,j]:
                    D[i,j] = D[i,k] + D[k,j]
                    D[j,i] = D[i,k] + D[k,j]
    
    return D


def _noise_general_metric_repair(orig_matrix, sd):
    &#34;&#34;&#34;Return a matrix D&#39; with noise by metric repair (DOMR) algorithm.&#34;&#34;&#34;
    
    D = np.array(orig_matrix, copy=True)
    N = D.shape[0]
    
    for i in range(N-1):                        # noise introduction
        for j in range(i+1,N):
            new_distance = 0.0
            while new_distance &lt;= 0.0:
                new_distance = D[i,j] * np.random.normal(loc=1.0, scale=sd)
            D[i,j] = new_distance
            D[j,i] = new_distance
            
    l, r = np.zeros_like(D), np.zeros_like(D)
    for k in range(N):                          # metric repair: general metric repair
        for i in range(N):
            for j in range(i):
                if D[i,j] &gt;= D[i,k] + D[k,j]:
                    l[i,j] += 1
                    r[i,k] += 1
                    r[j,k] += 1
    for k in range(N):                          # metric repair: general metric repair
        for i in range(N):
            for j in range(i):
                if D[i,j] &gt;= D[i,k] + D[k,j]:
                    if l[i,j] &gt; max(r[i,k], r[j,k]):
                        D[i,j] = D[i,k] + D[k,j]
                        D[j,i] = D[i,k] + D[k,j]
                    elif r[i,k] &gt; r[j,k]:
                        D[i,k] = D[i,j] - D[j,k]
                        D[k,i] = D[i,j] - D[j,k]
                    else:
                        D[j,k] = D[i,j] - D[i,k]
                        D[k,j] = D[i,j] - D[i,k]
    
    return D


# --------------------------------------------------------------------------
#                        WRONG TOPOLOGY NOISE
#   
# --------------------------------------------------------------------------
    
def convex_linear_comb(D1, D2, alpha=0.05, first_only=False):
    &#34;&#34;&#34;Convex linear combination of distance matrices.
    
    Returns the convex linear combinations of two distance matrices
        D1&#39; = (1-alpha) * D1 + alpha * D2
        D2&#39; = (1-alpha) * D2 + alpha * D1
    
    Parameters
    ----------
    D1 : 2-dimensional numpy array
        The first distance matrix.
    D2 : 2-dimensional numpy array
        The second distance matrix.
    alpha : float, optional
        Disturbance parameter, the default is 0.05.
    first_only : bool, optional
        If True, only return the disturbed first matrix. The default is False.
    
    Returns
    -------
    2-dim. numpy array or tuple of 2 matrices
        The disturbed distance matrix or matrices.
        
    References
    ----------
    .. [1] P. F. Stadler, M. Geiß, D. Schaller, A. López Sánchez, M. González 
       Laffitte, D. Valdivia, M. Hellmuth, M. Hernández Rosales.
       From pairs of most similar sequences to phylogenetic best matches.
       In: Alg. Mol. Biol., 2020, 15, 5.
       doi: 10.1186/s13015-020-00165-2.
    &#34;&#34;&#34;
    if not first_only:
        if D1.shape == D2.shape:
            return ((1-alpha) * D1 + alpha * D2,
                    (1-alpha) * D2 + alpha * D1)
        
        if D1.shape &gt; D2.shape:
            D1, D2 = D2, D1                         # now D1 is smaller
            swap = True
        else:
            swap = False
        
        N1, N2 = D1.shape[0], D2.shape[0]
        D1_alpha = (1-alpha) * D1 + alpha * D2[:N1,:N1]
        D2_alpha = (1-alpha) * D2
        
        for i in range(N2 // N1):
            for j in range(N2 // N1):
                D2_alpha[i*N1:i*N1+N1, j*N1:j*N1+N1] += alpha * D1
                if i == (N2 // N1) - 1 and i == j:
                    D2_alpha[i*N1+N1:N2, j*N1+N1:N2] += alpha * D1[:(N2%N1), :(N2%N1)]
                if i == (N2 // N1) - 1:
                    D2_alpha[i*N1+N1:N2, j*N1:j*N1+N1] += alpha * D1[:(N2%N1), :]
                if j == (N2 // N1) - 1:
                    D2_alpha[i*N1:i*N1+N1, j*N1+N1:N2] += alpha * D1[:, :(N2%N1)]
        
        if swap:
            return D2_alpha, D1_alpha
        else:
            return D1_alpha, D2_alpha
    
    else:
        if D1.shape == D2.shape:
            return (1-alpha) * D1 + alpha * D2
        
        N1, N2 = D1.shape[0], D2.shape[0]
        if N1 &lt; N2:
            return (1-alpha) * D1 + alpha * D2[:N1,:N1]
        else:
            D1_alpha = (1-alpha) * D1
            for i in range(N1 // N2):
                for j in range(N1 // N2):
                    D1_alpha[i*N2:i*N2+N2, j*N2:j*N2+N2] += alpha * D2
                    if i == (N1 // N2) - 1 and i == j:
                        D1_alpha[i*N2+N2:N1, j*N2+N2:N1] += alpha * D2[:(N1%N2), :(N1%N2)]
                    if i == (N1 // N2) - 1:
                        D1_alpha[i*N2+N2:N1, j*N2:j*N2+N2] += alpha * D2[:(N1%N2), :]
                    if j == (N1 // N2) - 1:
                        D1_alpha[i*N2:i*N2+N2, j*N2+N2:N1] += alpha * D2[:, :(N1%N2)]
            return D1_alpha


def wrong_topology_matrix(OGT):
    &#34;&#34;&#34;Return a wrong topology matrix by rearranging the edges of a binary tree.&#34;&#34;&#34;
    
    distances = [v.dist for v in OGT.preorder()][1:]    # do not include root,
    if len(distances) % 2 != 0:                         # observable gene tree (OGT)
        print(&#34;List of distances is not even!&#34;)         # is binary and not planted,
        return                                          # hence |E| should be even
    random.shuffle(distances)
    
    random_tree = Tree(TreeNode(label=0, dist=0.0))
    id_counter = 1
    current_leaves = [random_tree.root]
    
    while distances:
        v = current_leaves.pop(random.randint(0, len(current_leaves)-1))
        dist1, dist2 = distances.pop(), distances.pop()
        new_child1 = TreeNode(label=id_counter, dist=dist1)
        new_child2 = TreeNode(label=id_counter+1, dist=dist2)
        v.add_child(new_child1)
        v.add_child(new_child2)
        current_leaves.extend(v.children)
        id_counter += 1
    
    random_leaves = [l for l in random_tree.leaves()]   # implicit random bijection
    random.shuffle(random_leaves)                       # to original tree
    
    _, D = distance_matrix(random_tree, leaf_order=random_leaves)
    return D


# --------------------------------------------------------------------------
#                           METRIC CHECK
#   
# --------------------------------------------------------------------------

def _check_metric(matrix):
    &#34;&#34;&#34;Check whether a given matrix is a metric.&#34;&#34;&#34;
    
    N = matrix.shape[0]
    for i in range(N):
        if matrix[i,i] != 0.0:
            print(&#34;Not all diagonal elements zero!&#34;)
            return False
    for i in range(N-1):
        for j in range(i+1,N):
            if matrix[i,j] != matrix[j,i]:
                print(&#34;Not symmetrical for&#34;,i,j)
                return False
            if abs(matrix[i,j] - np.min(matrix[i,:] + matrix[:,j])) &gt; 1e-8:
                print(&#34;Violation of triangle inequality!&#34;,
                      i, j, np.min(matrix[i,:] + matrix[:,j]), matrix[i,j])
                return False
    return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="asymmetree.treeevolve.NoisyMatrix.convex_linear_comb"><code class="name flex">
<span>def <span class="ident">convex_linear_comb</span></span>(<span>D1, D2, alpha=0.05, first_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convex linear combination of distance matrices.</p>
<p>Returns the convex linear combinations of two distance matrices
D1' = (1-alpha) * D1 + alpha * D2
D2' = (1-alpha) * D2 + alpha * D1</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>D1</code></strong> :&ensp;<code>2-dimensional numpy array</code></dt>
<dd>The first distance matrix.</dd>
<dt><strong><code>D2</code></strong> :&ensp;<code>2-dimensional numpy array</code></dt>
<dd>The second distance matrix.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Disturbance parameter, the default is 0.05.</dd>
<dt><strong><code>first_only</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, only return the disturbed first matrix. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>2-dim. numpy array</code> or <code>tuple</code> of <code>2 matrices</code></dt>
<dd>The disturbed distance matrix or matrices.</dd>
</dl>
<h2 id="references">References</h2>
<p>.. [1] P. F. Stadler, M. Geiß, D. Schaller, A. López Sánchez, M. González
Laffitte, D. Valdivia, M. Hellmuth, M. Hernández Rosales.
From pairs of most similar sequences to phylogenetic best matches.
In: Alg. Mol. Biol., 2020, 15, 5.
doi: 10.1186/s13015-020-00165-2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convex_linear_comb(D1, D2, alpha=0.05, first_only=False):
    &#34;&#34;&#34;Convex linear combination of distance matrices.
    
    Returns the convex linear combinations of two distance matrices
        D1&#39; = (1-alpha) * D1 + alpha * D2
        D2&#39; = (1-alpha) * D2 + alpha * D1
    
    Parameters
    ----------
    D1 : 2-dimensional numpy array
        The first distance matrix.
    D2 : 2-dimensional numpy array
        The second distance matrix.
    alpha : float, optional
        Disturbance parameter, the default is 0.05.
    first_only : bool, optional
        If True, only return the disturbed first matrix. The default is False.
    
    Returns
    -------
    2-dim. numpy array or tuple of 2 matrices
        The disturbed distance matrix or matrices.
        
    References
    ----------
    .. [1] P. F. Stadler, M. Geiß, D. Schaller, A. López Sánchez, M. González 
       Laffitte, D. Valdivia, M. Hellmuth, M. Hernández Rosales.
       From pairs of most similar sequences to phylogenetic best matches.
       In: Alg. Mol. Biol., 2020, 15, 5.
       doi: 10.1186/s13015-020-00165-2.
    &#34;&#34;&#34;
    if not first_only:
        if D1.shape == D2.shape:
            return ((1-alpha) * D1 + alpha * D2,
                    (1-alpha) * D2 + alpha * D1)
        
        if D1.shape &gt; D2.shape:
            D1, D2 = D2, D1                         # now D1 is smaller
            swap = True
        else:
            swap = False
        
        N1, N2 = D1.shape[0], D2.shape[0]
        D1_alpha = (1-alpha) * D1 + alpha * D2[:N1,:N1]
        D2_alpha = (1-alpha) * D2
        
        for i in range(N2 // N1):
            for j in range(N2 // N1):
                D2_alpha[i*N1:i*N1+N1, j*N1:j*N1+N1] += alpha * D1
                if i == (N2 // N1) - 1 and i == j:
                    D2_alpha[i*N1+N1:N2, j*N1+N1:N2] += alpha * D1[:(N2%N1), :(N2%N1)]
                if i == (N2 // N1) - 1:
                    D2_alpha[i*N1+N1:N2, j*N1:j*N1+N1] += alpha * D1[:(N2%N1), :]
                if j == (N2 // N1) - 1:
                    D2_alpha[i*N1:i*N1+N1, j*N1+N1:N2] += alpha * D1[:, :(N2%N1)]
        
        if swap:
            return D2_alpha, D1_alpha
        else:
            return D1_alpha, D2_alpha
    
    else:
        if D1.shape == D2.shape:
            return (1-alpha) * D1 + alpha * D2
        
        N1, N2 = D1.shape[0], D2.shape[0]
        if N1 &lt; N2:
            return (1-alpha) * D1 + alpha * D2[:N1,:N1]
        else:
            D1_alpha = (1-alpha) * D1
            for i in range(N1 // N2):
                for j in range(N1 // N2):
                    D1_alpha[i*N2:i*N2+N2, j*N2:j*N2+N2] += alpha * D2
                    if i == (N1 // N2) - 1 and i == j:
                        D1_alpha[i*N2+N2:N1, j*N2+N2:N1] += alpha * D2[:(N1%N2), :(N1%N2)]
                    if i == (N1 // N2) - 1:
                        D1_alpha[i*N2+N2:N1, j*N2:j*N2+N2] += alpha * D2[:(N1%N2), :]
                    if j == (N1 // N2) - 1:
                        D1_alpha[i*N2:i*N2+N2, j*N2+N2:N1] += alpha * D2[:, :(N1%N2)]
            return D1_alpha</code></pre>
</details>
</dd>
<dt id="asymmetree.treeevolve.NoisyMatrix.noisy_matrix"><code class="name flex">
<span>def <span class="ident">noisy_matrix</span></span>(<span>orig_matrix, sd, metric_repair='reject')</span>
</code></dt>
<dd>
<div class="desc"><p>Disturb a distance matrix (which must be a metric) with random noise.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>orig_matrix</code></strong> :&ensp;<code>2-dimensional numpy array</code></dt>
<dd>The distance matrix.</dd>
<dt><strong><code>sd</code></strong> :&ensp;<code>float</code></dt>
<dd>Disturbance parameter. Serves as standard deviation of a normal
distrubition with mean 1.0.</dd>
<dt><strong><code>metric_repair</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Strategy to ensure that the resulting matrix is still a metric and,
in particular, satisfies the triangle inequality.
The default is 'reject', see [1]. Other avaible options are 'general'
and 'DOMR', see [2].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>2-dim. numpy array</code></dt>
<dd>The disturbed distance matrix.</dd>
</dl>
<h2 id="references">References</h2>
<p>.. [1] P. F. Stadler, M. Geiß, D. Schaller, A. López Sánchez, M. González
Laffitte, D. Valdivia, M. Hellmuth, M. Hernández Rosales.
From pairs of most similar sequences to phylogenetic best matches.
In: Alg. Mol. Biol., 2020, 15, 5.
doi: 10.1186/s13015-020-00165-2.
.. [2] A. C. Gilbert, L. Jain.
If it ain't broke, don't
x it: Sparse metric repair.
In: 2017 55th Annual Allerton Conference on Communication, Control, and
Computing (Allerton), pages 612-619, Monticello, IL, USA, October 2017.
IEEE. ISBN 978-1-5386-3266-6.
doi: 10.1109/ALLERTON.2017.8262793.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def noisy_matrix(orig_matrix, sd, metric_repair=&#39;reject&#39;):
    &#34;&#34;&#34;Disturb a distance matrix (which must be a metric) with random noise.
    
    Parameters
    ----------
    orig_matrix : 2-dimensional numpy array
        The distance matrix.
    sd : float
        Disturbance parameter. Serves as standard deviation of a normal
        distrubition with mean 1.0.
    metric_repair : str, optional
        Strategy to ensure that the resulting matrix is still a metric and,
        in particular, satisfies the triangle inequality.
        The default is &#39;reject&#39;, see [1]. Other avaible options are &#39;general&#39;
        and &#39;DOMR&#39;, see [2].
    
    Returns
    -------
    2-dim. numpy array
        The disturbed distance matrix.
        
    References
    ----------
    .. [1] P. F. Stadler, M. Geiß, D. Schaller, A. López Sánchez, M. González 
       Laffitte, D. Valdivia, M. Hellmuth, M. Hernández Rosales.
       From pairs of most similar sequences to phylogenetic best matches.
       In: Alg. Mol. Biol., 2020, 15, 5.
       doi: 10.1186/s13015-020-00165-2.
    .. [2] A. C. Gilbert, L. Jain.
       If it ain&#39;t broke, don&#39;t  x it: Sparse metric repair. 
       In: 2017 55th Annual Allerton Conference on Communication, Control, and
       Computing (Allerton), pages 612-619, Monticello, IL, USA, October 2017.
       IEEE. ISBN 978-1-5386-3266-6.
       doi: 10.1109/ALLERTON.2017.8262793.
    &#34;&#34;&#34;
    
    if metric_repair == &#39;general&#39;:
        return _noise_general_metric_repair(orig_matrix, sd)
    elif metric_repair == &#39;DOMR&#39;:
        return _noise_metric_repair_DOMR(orig_matrix, sd)
    elif metric_repair == &#39;reject&#39;:
        return _noise_reject_method(orig_matrix, sd)
    else:
        raise ValueError(&#34;illegal argument &#39;{}&#39;&#34;.format(metric_repair))</code></pre>
</details>
</dd>
<dt id="asymmetree.treeevolve.NoisyMatrix.wrong_topology_matrix"><code class="name flex">
<span>def <span class="ident">wrong_topology_matrix</span></span>(<span>OGT)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a wrong topology matrix by rearranging the edges of a binary tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrong_topology_matrix(OGT):
    &#34;&#34;&#34;Return a wrong topology matrix by rearranging the edges of a binary tree.&#34;&#34;&#34;
    
    distances = [v.dist for v in OGT.preorder()][1:]    # do not include root,
    if len(distances) % 2 != 0:                         # observable gene tree (OGT)
        print(&#34;List of distances is not even!&#34;)         # is binary and not planted,
        return                                          # hence |E| should be even
    random.shuffle(distances)
    
    random_tree = Tree(TreeNode(label=0, dist=0.0))
    id_counter = 1
    current_leaves = [random_tree.root]
    
    while distances:
        v = current_leaves.pop(random.randint(0, len(current_leaves)-1))
        dist1, dist2 = distances.pop(), distances.pop()
        new_child1 = TreeNode(label=id_counter, dist=dist1)
        new_child2 = TreeNode(label=id_counter+1, dist=dist2)
        v.add_child(new_child1)
        v.add_child(new_child2)
        current_leaves.extend(v.children)
        id_counter += 1
    
    random_leaves = [l for l in random_tree.leaves()]   # implicit random bijection
    random.shuffle(random_leaves)                       # to original tree
    
    _, D = distance_matrix(random_tree, leaf_order=random_leaves)
    return D</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="asymmetree.treeevolve" href="index.html">asymmetree.treeevolve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="asymmetree.treeevolve.NoisyMatrix.convex_linear_comb" href="#asymmetree.treeevolve.NoisyMatrix.convex_linear_comb">convex_linear_comb</a></code></li>
<li><code><a title="asymmetree.treeevolve.NoisyMatrix.noisy_matrix" href="#asymmetree.treeevolve.NoisyMatrix.noisy_matrix">noisy_matrix</a></code></li>
<li><code><a title="asymmetree.treeevolve.NoisyMatrix.wrong_topology_matrix" href="#asymmetree.treeevolve.NoisyMatrix.wrong_topology_matrix">wrong_topology_matrix</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>